---
layout:     post
title:      Wireshark分析tcp协议
subtitle:   Wireshark 分析tcp 协议
date:       2019-09-28
author:     Lij
header-img: img/post-bg-coffee.jpeg
catalog: true
tags:
    - 计算机网络
---

### 一、知识点归纳
#### wireshark与对应的OSI七层模型

![](/img/Wireshark分析tcp协议/wireshark与对应的OSI七层模型.png)  
#### TCP包的具体内容
 从下图可以看到wireshark捕获到的TCP包中的每个字段。
 
![](/img/Wireshark分析tcp协议/对应tcp字段.png)  

##### 关键字段解释：
-    序号字段（tcp.seq）：TCP是面向字节流的（就是说TCP是传输时是按照一个一个字节来传送的），所以TCP连接中传送的数据流中的每一个字节都编上一个序号。序号字段的值则指的是本报文段所发送的数据的第一个字节的序号。   

        例如，一报文段的序号字段值是301，而携带的数据共100个字节，这就表明本报文段的最后一个字节的序号为400，故下一个报文段的数据序号应从401开始。    
        
    -    确认号字段（tcp.ack）：是期望收到对方的下一个报文的数据的第一个字节的序号。若确认号=N，则表明到序号N-1为止的所有数据都已正确收到。
    
         例如，B正确收到了A发送过来的一个报文段，其序号字段是指501，而数据长度是200字节（序号501～700），这表明B正确收到了A发送的到序号700为止的数据。因此B期望收到A的下一个数据序号为701，于是B在发送给A的确认报文段中把确认号置为701。
        
-    确认位（tcp.flags.ack）：只有当ACK=1时确认号字段才有效。当ACK为0时，确认号无效。
    -    同步位（tcp.flags.syn）：同步SYN=1表示这是一个连接请求或连接接收报文。
    当SYN=1，ACK=0时，表明这是一个连接请求报文，对方若同意连接，则在响应报文中使用SYN=1，ACK=1。即，SYN=1就表示这是一个连接请求报文或者连接接收报文。
    
    -    终止位（tcp.flags.fin）：用来释放一个连接，FIN=1表明此报文段的发送方的数据已经发送完毕，并请求释放传输连接。
    
    -    窗口字段 （tcp.window_size_value）：指出了现在允许对方发送的数据量，接收方的数据缓存空间是有限的，故用窗口值作为接收方让发送方设置其发送窗口的依据（拥塞控制，流量控制的依据）
    
#### tcp 协议建立连接，传输数据，释放连接事例：

![](/img/Wireshark分析tcp协议/tcp协议图解.jpg) 

### 二、三次握手建立TCP连接 分析  
![](/img/Wireshark分析tcp协议/tcp协议图解.jpg)    

图中可以看到wireshark截获到了三次握手的三个数据包。第四个包才是HTTP的， 这说明HTTP的确是使用TCP建立连接的。

#### 第一次握手数据包

![](/img/Wireshark分析tcp协议/第一次握手.jpg)   

客户机的TCP首先向服务器的TCP发送一个连接请求报文段。这个特殊的报文段中不含应用层数据，其首部中的SYN标示位置为1，另外，客户机会随机选择一个起始序号seq=x（连接请求报文不携带任何数据，但要消耗一个序号）

#### 第二次握手数据包

服务器的TCP 收到请求报文段后，如同意建立连接，就向客户机发回确认，并为该TCP连接分配TCP缓存和变量。在确认报文段中，SYN和ACK位都被置为1，确认号字段的值为x+1 ，并且服务器随机产生一个起始序号seq=y (确认报文不携带数据，但也要消耗掉一个序号)。确认报文段同样不包含任何应用层数据；
![](/img/Wireshark分析tcp协议/第二次握手.jpg)   

#### 第三次握手数据包

![](/img/Wireshark分析tcp协议/第三次握手.jpg)   

当客户机收到确认报文段后，还要向服务器给出确认，并且也要给该连接分配缓存和变量，这个报文段的ACK被置为1，序号为X+1,确认号字段ack=y+1。该报文段可以携带数据，如果不携带数据则不消耗序号；




